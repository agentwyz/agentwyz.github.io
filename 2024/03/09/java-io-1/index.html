<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Java网络编程 | lumos</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 5.4.2"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java网络编程</h1><a id="logo" href="/.">lumos</a><p class="description">计算美学</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java网络编程</h1><div class="post-meta">2024-03-09</div><div class="post-content"><h3 id="几种IO模式"><a href="#几种IO模式" class="headerlink" title="几种IO模式"></a>几种IO模式</h3><p>首先我们需要弄明白几种IO模型, 关于基础知识这块我觉得已经说臭了:)。 </p>
<p>首先说同步IO, 同步IO指的是, 你需要不断的监控资源的状态, 如果资源是可读或者可写的, 那么就会读, 如果资源不可以读或者写, 就会出现下面两种情况:</p>
<ul>
<li>BIO：指的是阻塞IO, 读取不到数据, 会阻塞当前线程, 比如sleep(100)</li>
<li>NIO:指的是非阻塞IO，读取不到数据, 不会阻塞当前线程, 但是会返回一个错误编号。</li>
</ul>
<p>第三种方式就是AIO, 这种方式的好处就是, 你只要将资源挂在线程上面, 如果可以读或者可写, 那么它会自动告诉你</p>
<p>区分这三个东西, 也非常简单, 那就是BIO关心的是我要读, NIO关心的就是我可以读了, AIO关心的就是读完了</p>
<p>对比这三种方式, <strong>显然AIO这种方式更好, 因为BIO的阻塞会影响性能, 其次NIO的不断监听资源又会耗费很多的时间</strong>。 </p>
<p>说完了这三种IO模型, 接下来我们来说一说关于如何高效的使用线程去读取资源, 记住当我们已经引入多线程, IO多路复用这些概念的时候, 我们需要处理的资源往往都不是一个。</p>
<h3 id="IO模式的线程改进"><a href="#IO模式的线程改进" class="headerlink" title="IO模式的线程改进"></a>IO模式的线程改进</h3><p>首先我们来看第一种IO模式的线程改进, 因为第一种IO模式是阻塞的, 所以一旦没有资源就会阻塞, 那么我们就要给每个连接都绑定一个线程, 这样就不会出现程序一直挂死的情况, </p>
<p>在Java中我们可以写出代码的原型:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(PORT);</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                <span class="comment">//每次来一个连接事件, 我们就新建一个线程</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Handler</span>(ss.accept())).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>但是这种做法的坏处也是显而易见的</strong></p>
<ol>
<li>操作系统的线程资源是十分昂贵的, 每次创建一个线程的就对应一段资源的分配,</li>
<li>线程直接切换导致性能急剧下降, 可能还没有单线程环境下面好。</li>
</ol>
<p>下面我们就通过非阻塞的方式来解决上面的问题, 在Java中我们可以使用scoketchannel, 去配置非阻塞</p>
<h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><p>当tcp三次握手成功, tcp连接成功建立后, 操作系统内核会为每一个连接创建配套的基础设施, 比如发送缓冲区域,发送缓冲区的大小可以通过套接字选项来改变, 当我们的应用程序调用write函数的时候, 实际上做的事情就是把数据从<strong>应用程序中拷贝到操作系统的内核的发送缓冲区</strong></p>
<p><strong>那么发送缓冲区的大小就是一个比较重要的因素。</strong></p>
<p>第一种情况就是, 操作系统内核的发送缓冲区足够大, 可以直接容纳这份数据, 那么我们的程序就会返回对应的缓冲区大小。</p>
<p>第二种情况就是, 操作系统的发送缓冲区不足以容纳这份数据, 这时候应用程序被阻塞, 也就是应用程序在write函数处停留, 不直接返回, 但是操作系统会源源不断的处理发送缓冲区中的数据,</p>
<p>操作系统按照TCP/IP的语义, 将取出的包裹封装成为TCP的MSS包, 以及IP的MTU包, 最后走数据链路层将数据发送出去, 这样我们的缓冲区域就会不断的空出来。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux内核发送缓冲区-----&gt;用户1</span><br></pre></td></tr></table></figure>

<p><strong>于是又可以继续从应用程序搬离一部分到内核的发送缓冲区</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户 ----&gt; linux内核发送缓冲区</span><br></pre></td></tr></table></figure>

<p>这样就会一直下去, 直到某一时刻, 应用程序的数据可以完全放置到发送缓冲区中, 这样就会一直进行下去, 到某一时刻, 应用程序的数据可以完全放置到发送缓冲区中, 这时候write阻塞调用返回</p>
<p>read函数, 要求从操作系统内核从套接字描述子socketfd读取最多多少字节, 并将结果存储到buffer中, 返回值告诉我们实际读取的字节数目,</p>
<ul>
<li>如果返回值为0, 表示EOF， 这在网络中表示对端发送了FIN包, 要处理断连的情况</li>
<li>如果返回值为-1, 表示出错</li>
</ul>
</div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul></div><div class="post-nav"><a class="pre" href="/2024/03/21/event/"></a><a class="next" href="/2023/10/12/functionprograming/">函数式编程的常见误区</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/GOLANG/" style="font-size: 15px;">GOLANG</a> <a href="/tags/function-programming/" style="font-size: 15px;">function programming</a> <a href="/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/" style="font-size: 15px;">程序语言设计</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/memory/" style="font-size: 15px;">memory</a> <a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size: 15px;">总结</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2024/03/28/invokedy/">invokedy</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/03/23/method/">method</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/03/23/process/">process</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/03/21/event/">event</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/03/09/java-io-1/">Java网络编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/10/12/functionprograming/">函数式编程的常见误区</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/08/24/go-error/">Go语言错误处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/07/10/js-object/">JavaScript的面向对象详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/07/10/heap-or-stack/">值放在栈上还是堆上</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/24/Ycombinator/">Y Combinator</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="www.yinwang.org" title="王垠老师" target="_blank">王垠老师</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">lumos.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>